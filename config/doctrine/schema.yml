# ==
#   View in the hekdb for syncing the residents data
# ==

HekdbCurrentResidents:
  connection: hekdb
  tableName: letztezimmerbelegung
  columns:
    vorname:
      name: vorname as first_name
      type: string
    nachname:
      name: nachname as last_name
      type: string
    nutzerid:
      name: nutzerid as id
      primary: true
      type: integer   
    zimmernummer:
      name: zimmernummer as room_no
      type: string
    einzug:
      name: einzug as move_in
      type: date
    auszug:
      name: auszug as move_out
      type: date
  options:
    charset: latin1
    

# ===
# Tables required by asterisk.
# === 

# Asterisk writes call detail records to this table as specified in
# /etc/asterisk/cdr_pgsql.conf. A postgres trigger ought to allocate the
# calls to an user and calculates the fees.
AsteriskCdr:
  connection: hekphone
  tableName: asterisk_cdr
  columns:
    calldate: 
      type: timestamp
      notnull: true
      default: now()
    clid: 
      type: string
      notnull: true
    src: 
      type: string
      notnull: true
    dst: 
      type: string
      notnull: true
    dcontext: 
      type: string
      notnull: true
    channel: 
      type: string
      notnull: true
    dstchannel: 
      type: string
      notnull: true
    lastapp: 
      type: string
      notnull: true
      primary: false
    lastdata: 
      type: string
      notnull: true
    duration: 
      type: integer(8)
      notnull: true
      default: '0'
    billsec: 
      type: integer(8)
      notnull: true
      default: '0'
    disposition: 
      type: string
      notnull: true
    amaflags: 
      type: integer(8)
      notnull: true
      default: '0'
    accountcode: 
      type: string
      notnull: true
    uniqueid: 
      type: string
      notnull: true
    userfield: 
      type: string
      notnull: true
    billed: 
      type: boolean
      notnull: true
      default: 'false' 

AsteriskExtensions:
  connection: hekphone
  tableName: asterisk_extensions
  columns:
    id:
      type: integer(4)
      fixed: false
      unsigned: false
      primary: true
      sequence: asterisk_extensions_id
    context:
      type: string()
      fixed: false
      unsigned: false
      notnull: true
      primary: false
    exten:
      type: string()
      fixed: false
      unsigned: false
      notnull: true
      primary: false
    priority:
      type: integer(2)
      fixed: false
      unsigned: false
      notnull: true
      default: '0'
      primary: false
    app:
      type: string()
      fixed: false
      unsigned: false
      notnull: true
      primary: false
    appdata:
      type: string()
      fixed: false
      unsigned: false
      notnull: false
      primary: false

AsteriskVoicemail:
  connection: hekphone
  tableName: asterisk_voicemail
  columns:
    uniqueid:
      type: integer
      notnull: true
    customer_id:
      type: string(11)
      notnull: true
      default: '0'
    context:
      type: string(50)
      notnull: true
      default: '0'
    mailbox:
      type: string(11)
      notnull: true
      default: '0'
    password:
      type: string(10)
      notnull: true
      default: '0'
    fullname:
      type: string(150)
      notnull: true
      default: ''
    email:
      type: string(50)
      email: true
      notnull: true
    pager:
      type: string(50)
      notnull: true
      default: ''
    tz:
      type: string(10)
      notnull: true
      default: 'central'
    attach:
      type: string(4)
      notnull: true
      default: 'yes'
    saycid:
      type: string(4)
      notnull: true
      default: 'yes'
    dialout:
      type: string(4)
      notnull: true
      default: ''
    callback:
      type: string(10)
      notnull: true
      default: ''
    review:
      type: string(4)
      notnull: true
      default: 'no'
    operator:
      type: string(4)  
      notnull: true
      default: 'no'
    envelope:
      type: string(4)  
      notnull: true
      default: 'no'
    sayduration:
      type: string(4)  
      notnull: true
      default: 'no'
    saydurationm:
      type: integer(4)  
      notnull: true
      default: 1
    sendvoicemail:
      type: string(4)  
      notnull: true
      default: 'no'
    delete:
      type: string(4)  
      notnull: true
      default: 'no'
    nextaftercmd:
      type: string(4)  
      notnull: true
      default: 'yes'
    forcename:
      type: string(4)  
      notnull: true
      default: 'no'
    forcegreetings:
      type: string(4)  
      notnull: true
      default: 'no'
    hidefromdir:
      type: string(4)  
      notnull: true
      default: 'yes'
    stamp:
      type: timestamp
   
# We want to reduce redundant information in the database and the state "unlocked/
# locked" belongs to a user, not a phone, this "table" asterisk_sip is supposed to
# be a view that collects all data from Phones and additionally fetches the
# locked/unlocked state from residents. (TODO: and the culture/language!?)      
# Unfortunatele, it seems impossible to implement this in a clean way with doctrine.
# So after you build the database from the schema, you should DELETE the 
# the asterisk_sip table and create the view.
# As asterisk needs to write to some fields in asterisk_sip some 
# "onupdate do instead" rules should be defined.
# Because the view uses a typecast from boolean (resident->locked) to the
# enum 'context' which is either 0: locked or 1: unlocked, you have to create 
# this typecast first. This can be done with the postgres-01-typecast-bool-context.sql
# file. (psql <database> <username> - f postgres-01-typecast-bool-context.sql)
# The typecast also automatically forces all telephones in rooms with no assigned
# resident to be locked!
# Now, table can be dropped and the view and the rules can can easily be created 
# via postgres02-asterisk_sip-view.sql:
#   psql <database> <username> - f postgres-02-asterisk_sip-view.sql
AsteriskSip:
  connection: hekphone
  tableName: asterisk_sip
  columns:
    id:
      type: integer(11)
      notnull: true
      primary: true
      autoincrement: true
##  FIXME: name == 1XXX (XXX: room number) ?
    name:
      type: string(80)
      notnull: true
      default: ''
    'type':
      type: enum
      length: 6
      values: ['user','peer','friend']
      notnull: true
      default: 'friend'
    callerid:
      type: string(80)
## Parameter to identify the user:
    defaultuser:
      type: string(80)
      notnull: true
      default: ''
    secret:
      type: string(80)
## As our telephones desperately try to register, we need host=dynamic:
    host:
      type: string(31)
      notnull: true
      default: dynamic
## With host = dynamic: This "defaultip" is used, if the client is not registered.
## The DHCP configuration is created from this field and the following: 
    defaultip:
      type: string(15)
    mac:
      type: string(20)
      default: ''
## Maybe also fetch the language via a view from the residents table (->culture):
    language:
      type: string(2)
      default: 'de'
## The field mailbox (contains "mailboxid@context") equals a users id.
    mailbox:
      type: string(50)
## These fields are obviousely required by asterisk:
    regserver:
      type: string(20)
    regseconds:    # updated by asterisk periodically!
      type: string(20)
    ipaddr:        # updated by asterisk periodically!
      type: string(15)
      notnull: true
      default: ''
    port:          # updated by asterisk periodically!
      type: string(5)
      unsigned: true
      notnull: true
      default: ''
    fullcontact:
      type: string(80)
      notnull: true
      default: ''
    useragent:     # updated by asterisk!
      type: string(20)
      default: ''
## The field lastms...
    lastms:
      type: string(11)
      default: ''
         
# This table is the skeleton of the view asterisk_sip which specifies the
# sip friend of asterisk.
# It contains every neccessary information except "context" which is either
# "locked" (outgoing calls denied) or "unlocked" (allowed) because
# this information belongs to an user not to a telephone. So its stored in
# Bewohner->context.
# See comment on asterisk_sip!
Phones:
  connection: hekphone
  tableName: phones
  columns:
    id:
      type: integer(11)
      notnull: true
      primary: true
      autoincrement: true
##  FIXME: name == 1XXX (XXX: room number) ?
    name:
      type: string(80)
      notnull: true
      default: ''
    'type':
      type: enum
      length: 6
      values: ['user','peer','friend']
      notnull: true
      default: 'friend'
    callerid:
      type: string(80)
## Parameter to identify the user:
    defaultuser:
      type: string(80)
      notnull: true
      default: ''
    secret:
      type: string(80)
## As our telephones desperately try to register, we need host=dynamic:
    host:
      type: string(31)
      notnull: true
      default: dynamic
## With host = dynamic: This "defaultip" is used, if the client is not registered.
## The DHCP configuration is created from this field and the following: 
    defaultip:
      type: string(15)
    mac:
      type: string(20)
      default: ''
## Maybe also fetch the language via a view from the residents table (->culture):
    language:
      type: string(2)
      default: 'de'
## The field mailbox (contains "mailboxid@context") equals a users id.
    mailbox:
      type: string(50)
## These fields are obviousely required by asterisk:
    regserver:
      type: string(20)
    regseconds:    # updated by asterisk periodically (with time elapsed since registration?)
      type: string(20)
    ipaddr:        # updated by asterisk periodically with the current ip of the registered phone
      type: string(15)
      notnull: true
      default: ''
    port:          # updated by asterisk periodically with the port of the registered phone
      type: string(5)
      unsigned: true
      notnull: true
      default: ''
    fullcontact:
      type: string(80)
      notnull: true
      default: ''
    useragent:     # updated by asterisk (with the useragent of the registered phone?)
      type: string(20)
      default: ''
## The field lastms contains the time when qualify was checked for the last time.
## see https://issues.asterisk.org/view.php?id=14196
    lastms:       # updated by asterisk every time asterisk pings (qualifys) the phone
      type: string(11)
      default: ''
## Maybe required fields
#    regexten:   # not required (no warning if it's not present)
#      type: string(20)
#    fromuser:   # not required (no warning if it's not present)
#      type: string(20)
#    fromdomain: # not required (no warning if it's not present)
#      type: string(20)
#    callingpres:
#      type: enum
#      length: 20
#      values: ['allowed_not_screened','allowed_passed_screen','allowed_failed_screen','allowed','prohib_not_screened','prohib_passed_screen','prohib_failed_screen','prohib','unavailable']
#      default: 'allowed_not_screened'
#    permit: 
#      type: string(95)
#      default: 'NULL'
#    deny:
#      type: string(95)
#      default: 'NULL'
#      default: 'NULL'
#    md5secret:
#      type: string(80)
#      default: 'NULL'
#    remotesecret:
#      type: string(250)
##      default: 'NULL'
#    transport:
#      type: enum
#      length: 7
#      values: ['tcp','udp','tcp,udp']
#      default: 'NULL'
#      default: 'NULL'
#    nat:
#      type: string(5)
#      notnull: true
#      default: 'no'
#    accountcode:
#      type: string(20)
#      default: 'NULL'
#    amaflags:
#      type: string(13)
#      default: 'NULL'
#    callergroup:
#      type: string(10)
#      default: 'NULL'
#      default: 'NULL'
#      default: 'NULL'
## Defaults to rfc2833 which we use so we don't need it
#    dtmfmode:
#      type: string(7)
#      default: 'NULL'
#    fromuser:
#      type: string(80)
#      default: 'NULL'
#    fromdomain:
#      type: string(80)
#      default: 'NULL'
## Comment on http://www.voip-info.org/wiki/view/Asterisk+sip+insecure
## "this does not seem to work with 1.6+" we did not try it
#    insecure:
#      type: string(4)
#      default: 'NULL'
#      default: 'NULL'
#      default: 'NULL'
#    pickupgroup:
#       type: string(10)
#      default: 'NULL'
## Qualify Can be yes, no or a time in ms. This is done in sip.conf/general
#    qualify:
#      type: string(5)
#      default: yes
#      default: 'NULL'
#    regexten:
#      type: string(80)
#      default: 'NULL'
#    rtptimeout:
#      type: string(3)
#      default: 'NULL'
#    rtpholdtimeout:
#      type: string(3)
#      default: 'NULL'
#    setvar:
#      type: string(100)
#      default: 'NULL'
## Done in sip.conf/general
#    disallow:
#      type: string(100)
#      default: 'all'
#    allow:
#      type: string(100)
#      default: 'g729;ilbc;gsm;ulaw;alaw'
## Asterisk 1.6 uses defaultuser instead of username afaik
#    username:
#      type: string(80)
#      notnull: true
#      default: ''
#    subscribecontext:
#      type: string(80)
#      default: null
#    directmedia:
#      type: enum
#      length: 3
#      values: ['yes','no']
#      default: 'NULL'
#    trustrpid:
#      type: enum
#      length: 3
#      values: ['yes','no']
#      default: no'
#    sendrpid:
#      type: enum
#      length: 3
#      values: ['yes','no']
#      default: 'no'
#    progressinband:
#      type: enum
#      length: 3
#      values: ['yes','no']
#      default: 'no'
#    promiscredir:
#      type: enum
#      length: 3
#      values: ['yes','no']
#      default: 'no'
#    useclientcode:
#      type: enum
#      length: 3
#      values: ['yes','no']
#      default: yes
#    callcounter:
#      type: enum
#      length: 3
#      default: 'no'
#      values: ['yes', 'no']
#    busylevel:
#      type: integer(10)
#      unsigned: true
#      default: 'NULL'
#    allowoverlap:
#      type: enum
#      length: 3
#      values: ['yes', 'no']
#      default: 'yes'
#    allowsubscribe:
#      type: enum
#      values: ['yes', 'no']
#      default: 'yes'
#    allowtransfer:
#      type: enum
#      values: ['yes', 'no']
#      default: 'yes'
#    ignoresdpversion:
#      type: enum
#      values: ['yes', 'no']
#      default: 'no'
#    template:
#      type: string(100)
#      default: 'NULL'
#    videosupport:
#      type: enum
#      values: ['yes', 'no']
#      default: 'no'
#    maxcallbitrate:
#      type: integer(10)
#      unsigned: true
#      default: 'NULL'
#     rfc2833compensate:
#      type: enum
#      length: 3
#      values: ['yes', 'no']
#      default: 'yes'
#    #'session-timers':
#    #  type: enum
#    #  values: ['yes', 'no']
#    #  default: 'no'
#    #'session-expires':
#    #  type: integer(5)
#    #  unsigned: true
#    #  default: '1800'
#    #'session-minse':
#    #  type: integer(5)
#    #  unsigned: true
#    #  default: '90'
#    #'session-refresher':
#    #  type: enum
#    #  values: ['uac', 'uas']
#    #  default: 'uas'
#    t38pt_usertpsource:
#      type: enum
#      values: ['yes', 'no']
#      default: 'no'
#    outboundproxy:
#      type: string(250)
##      default: 'NULL'
#    callbackextension:
#      type: string(150)
##      default: 'NULL'
#    registertrying:
#      type: enum
#      values: ['yes', 'no']
#      default: 'yes'
#    timtert1:
#      type: integer(5)
#      unsigned: true
#      default: 500
#    timerb:
#      type: integer(8)
#      unsigned: true
#      default: 'NULL'
#    qualifyfreq:
#      type: integer(5)
#      unsigned: true
#      default: 120
#    contactpermit:
#      type: string(250)
##      default: 'NULL'
#    contactdeny:
#      type: string(250)
##      default: 'NULL'
#    lastms:
#      type: integer(11)
#      notnull: true

# ===
# Actual HEKPhone Tables 
# ===

Residents:
  connection: hekphone
  tableName: residents
  columns:
    id: 
      type: integer
      primary: true
    last_name: 
      type: string(50)
      notnull: true
    first_name: 
      type: string(50)
      notnull: true
    email:
      type: string (255)
      #unique: true
      email: true
    move_in: 
      type: date
      notnull: true
    move_out: date
    bill_limit: 
      type: integer(3)
      notnull: true
      default: '75'
    room:
      type: integer(3)
      unique: true
    warning1: 
      type: boolean
      default: false
    warning2: 
      type: boolean
      default: false
    unlocked:
      type: boolean
      default: false
    shortened_itemized_bill: 
      type: boolean
      default: true
    account_number: string(10)
    bank_number: string(8)
    password: string(255)
    hekphone: 
      type: boolean
      default: false
    culture:
      type: string(5)
      default: 'de_DE'
  relations:
    Rooms:
      local: room
      foreign: id
      type: one
    Banks:
      local: bank_number
      foreign: bank_number
      type: one
    Comments:
      local: id
      foreign: resident
      type: many
    Calls:
      local: id
      foreign: resident
      type: many
    Bills:
      local: id
      foreign: resident
      type: many

Rooms:
  connection: hekphone
  tableName: rooms
  columns:
    id: 
      type: integer(3)
      primary: true
      sequence: rooms_id
    room_no:
      type: integer(3)
      unique: true
    comment: string
    phone:
      type: integer(3)
      unique: true
  relations:
    Phones:
      local: phone
      foreign: id
      type: one
    Residents:
      local: id
      foreign: room
      type: many

Comments:
  connection: hekphone
  tableName: comments
  columns:
    resident: 
      type: integer(6)
      notnull: true
    stamp: 
      type: timestamp
      notnull: true
      default: now()
    comment: 
      type: string(1000)
      notnull: true
  relations:
    Residents:
      local: resident
      foreign: id
      type: one

Banks:
  connection: hekphone
  tableName: banks
  columns:
    bank_number: 
      type: string(8)
      notnull: true
      primary: true
      unique: true
    name: 
      type: string(80)
      notnull: true
    zip: 
      type: string(5)
      fixed: true
    locality: string(80)
  relations:
    Residents:
      local: bank_number
      foreign: bank_number
      type: many

Calls:
  connection: hekphone
  tableName: calls
  columns:
    id: 
      type: integer(7)
      primary: true
      sequence: calls_id
    resident: 
      type: integer(6)
      notnull: true
    extension: 
      type: string(10)
      notnull: true
    date: 
      type: timestamp
      default: now()
    duration: 
      type: string(6)
      notnull: true
    destination: 
      type: string(50)
      notnull: true
    charges: 
      type: decimal(18)
      notnull: true
    rate: 
      type: integer(6)
      notnull: true
    bill: 
      type: integer(6)
      default: '0'
  relations:
    Residents:
      local: resident
      foreign: id
      type: one
    Rates:
      local: rate
      foreign: id
      type: one

Bills:
  connection: hekphone
  tableName: bills
  columns:
    id: 
      type: integer(6)
      primary: true
      sequence: bills_id
    resident: 
      type: integer(6)
      notnull: true
      primary: false
    date: 
      type: date
      notnull: true
    amount: 
      type: decimal(18)
      notnull: true
    debit_failed: 
      type: boolean
      notnull: true
      default: 'false'
  relations:
    Residents:
      local: resident
      foreign: id
      type: one
#    Calls:
#      local: id
#      foreign: bill
#      type: many
# There's no relation to bills because as long as the call is not billed
# theres no bill id set. Thus the relation would be violated.
# This might be a flaw in the database design. (It's probably better to assign a     
# call to a bill in the moment the call is "billed" (transfered from asterisk_cdr
# to calls). A bill is then assigned to a user) FIXME?

Providers:
  connection: hekphone
  tableName: providers
  columns:
    id: 
      type: integer(1)
      primary: true
    name: 
      type: string(20)
      notnull: true
  relations:
    Rates:
      local: id
      foreign: provider
      type: many
            
RatesRegions:
  connection: hekphone
  tableName: rates_regions
  columns:
    id: 
      type: integer(6)
      primary: true
      sequence: rates_regions_id
    rate:
      type: integer(6)
      notnull: true
      unique: true
    region:
      type: integer(6)
      unique: true
  relations:
    Rates:
      local: rate
      foreign: id
      type: one
    Regions:
      local: region
      foreign: id
      type: many #one???

Regions:
  connection: hekphone
  tableName: regions
  columns:
    id: 
      type: integer(6)
      primary: true
    name: 
      type: string(80)
      notnull: true
      unique: true
  relations:
    RatesRegions:
      local: id
      foreign: region
      type: one # ONE or MANY?
    Prefixes:
      local: id
      foreign: region
      type: many

Rates:
  connection: hekphone
  tableName: rates
  columns:
    id: 
      type: integer(6)
      primary: true
    provider: 
      type: integer(1)
      notnull: true
    primary_time_begin: 
      type: time
      notnull: true
    primary_time_rate: 
      type: decimal(18)
      notnull: true
    secondary_time_begin: 
      type: time
    secondary_time_rate: 
      type: decimal(18)
    weekend: 
      type: boolean
      notnull: true
      default: 'true'
    week: 
      type: boolean
      notnull: true
      default: 'true'
    pulsing:
      type: enum
      values: ['1/1', '60/60', '30/1', '60/1', '60/0']
      notnull: true
    name: 
      type: string(80) 
      notnull: true
  relations:
    RatesRegions:
      local: id
      foreign: rate
      type: many
    Providers:
      local: provider
      foreign: id
      type: one

Prefixes:
  connection: hekphone
  tableName: prefixes
  columns:
    id: 
      type: integer(6)
      primary: true
      sequence: prefixes_id
    prefix: 
      type: string(20)
      notnull: true
    name: 
      type: string(80)
      notnull: true
    region: 
      type: integer(6)
      notnull: true
  relations:
    Regions:
      local: region
      foreign: id
      type: one
